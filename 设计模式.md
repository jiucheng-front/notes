 ##  一、面向对象编程
 
 ###  1.1链式调用
 
 
 ```javascript
 
 	var CheckObject = function(){};
 	CheckObject.prototype = function(){
 		checkName:function(){
 			// code
 			return this;
 		},
 		checkEmail:function(){
 			// code 
 			return this;
 		},
 		checkPassword:function(){
 			// code
 			return this;
 		}
 	}
 	//使用
 	var Check = new CheckObject()
 	Check.checkName().checkEmail().checkPassword();

 ```
 
 ###  1.2链式添加方法与链式调用
 
 ```javascript
 
 	Function.prototype.addMethod = function(name,fn){
 		this.prototype[name] = fn;
 		return this;
 	}
 	var Methods = function(){};
 	Methods.addMethod（"checkName",function(){
 		// code
 	}).addMethod("checkEmail",function(){
 		// code
 	})
 	// 使用
 	var Check = new Methods()
 	Check.checkName()
 
 ```

 ## 二、继承

 > 2.1 子类的的原型对象----类式继承

 ```javascript
	
	//声明父类
	function Parent(){
		this.parentValue = true;
		this.favorites = ['看书']
	}
	//为父类添加公有方法
	Parent.prototype.getParentValue = function(){
		return this.parentValue;
	}
	//声明子类
	function Child(){
		this.childValue = false;
	}
	// 继承父类
	Child.prototype =  new Parent()
	//为子类添加方法
	Child.prototype.getChildValue = function(){
		return this.childValue;
	}

	var instance = new Child()
	console.log(instance.getParentValue())  //true
	console.log(instance.getChildValue())   //false
	/*
	*注：使用instanceof检测某个对象是否是某个某个类的实例，
	*	或者说某个对象是否继承了某个类
	*/
	console.log(instance instanceof Parent) //true
	console.log(instance instanceof Child)  //true
	console.log(Child instanceof Parent)    //false 为何？Child的原型继承了父类

	console.log(Child.prototype instanceof Parent) //true
	/*
	*缺点：一个子类改变继承于父类的公有属性，其他子类会受到影响
	*	如何避免？？
	*/
	var child1 = new Parent()
	var child2 = new Parent()
	console.log(child2.favorites) //['看书']
	child1.favorites.push('旅游')
	console.lof(child2.favorites) //['看书','旅游']

 ```

> 2.2 创建即继承----构造函数继承

```javascript

	//声明父类
	function SuperClass(id){
		//值类型公有属性
		this.id = id;
		//引用类型公有属性
		this.books = ['Html','Css'];
	}
	//父类声明原型方法
	SuperClass.prototype.showBooks = function(){
		console.log(this.books)
	}
	//声明子类
	function ChildClass(id){
		//继承父类
		SuperClass.call(this,id)
	}

	var child1 = new ChildClass(1)
	var child2 = new ChildClass(2)
	child1.books.push('设计模式');
	console.log(child1.id)    //1
	console.log(child1.books) //['Html','Css','设计模式'];
	console.log(child2.id)    //2
	console.log(child2.books) //['Html','Css'];

	child1.showBooks()		  //TypeErrr
	/*
	* SuperClass.call(this,id)是构造函数继承的精华，call可以改变函数的作用域环境，
	* 因此在子类中对父类调用这个方法，就是将子类的变量在父类中执行一遍，由于父类中是给
	* this绑定属性的，因此子类也就继承了父类的公有属性，由于这种方法没有涉及原型prototype
	* 所以父类原型方法不会被子类继承，如果想要被继承就必须放在构造函数中，这样创建出来
	* 的每个实例都会单独拥有一份而不能共用，这样就违背了代码服用的原则。
	* 为了综合这两种模式的优点，有了组合式继承。
	*/

```










