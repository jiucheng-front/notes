 ##  一、面向对象编程
 
 ###  1.1链式调用
 
 
 ```javascript
 
 	var CheckObject = function(){};
 	CheckObject.prototype = function(){
 		checkName:function(){
 			// code
 			return this;
 		},
 		checkEmail:function(){
 			// code 
 			return this;
 		},
 		checkPassword:function(){
 			// code
 			return this;
 		}
 	}
 	//使用
 	var Check = new CheckObject()
 	Check.checkName().checkEmail().checkPassword();

 ```
 
 ###  1.2链式添加方法与链式调用
 
 ```javascript
 
 	Function.prototype.addMethod = function(name,fn){
 		this.prototype[name] = fn;
 		return this;
 	}
 	var Methods = function(){};
 	Methods.addMethod（"checkName",function(){
 		// code
 	}).addMethod("checkEmail",function(){
 		// code
 	})
 	// 使用
 	var Check = new Methods()
 	Check.checkName()
 
 ```

 ## 二、继承

 > 2.1 子类的的原型对象----类式继承

 ```javascript
	
	//声明父类
	function Parent(){
		this.parentValue = true;
		this.favorites = ['看书']
	}
	//为父类添加公有方法
	Parent.prototype.getParentValue = function(){
		return this.parentValue;
	}
	//声明子类
	function Child(){
		this.childValue = false;
	}
	// 继承父类
	Child.prototype =  new Parent()
	//为子类添加方法
	Child.prototype.getChildValue = function(){
		return this.childValue;
	}

	var instance = new Child()
	console.log(instance.getParentValue())  //true
	console.log(instance.getChildValue())   //false
	/**
	*注：使用instanceof检测某个对象是否是某个某个类的实例，
	*	或者说某个对象是否继承了某个类
	*/
	console.log(instance instanceof Parent) //true
	console.log(instance instanceof Child)  //true
	console.log(Child instanceof Parent)    //false 为何？Child的原型继承了父类

	console.log(Child.prototype instanceof Parent) //true
	/*
	*缺点：一个子类改变继承于父类的公有属性，其他子类会受到影响
	*	如何避免？？
	*/
	var child1 = new Parent()
	var child2 = new Parent()
	console.log(child2.favorites) //['看书']
	child1.favorites.push('旅游')
	console.lof(child2.favorites) //['看书','旅游']

 ```











